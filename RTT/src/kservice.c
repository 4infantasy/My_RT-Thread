
#include <rtthread.h>
#include <rthw.h>


char *rt_strncpy( char *dst, const char *src, rt_ubase_t n )
{

	if ( n != 0 ) {
	
		char *d = dst;
		const char *s = src;
		
		do {
		
			if ( (*d++ = *s++) == 0 ) {
			
				while ( --n != 0 )
					*d++ = 0;
				
				break;
			
			}
		
		} while ( --n != 0 );
	
	}
	
	return (dst);

}



/*
	__lowest_bit_bitmap[]解析

	将一个8位整形数的取值范围0~255作为数组的索引
	索引值第一个出现1（从最低位开始）的位号作为该数组索引下的成员值。

	举例：十进制数10的二进制位：0000 1010，从最低位开始，
	第一个出现1的位号为bit1，则有__lowest_bit_bitmap[10] = 1

	注意：只需要找到第一个出现1的位号即可。
*/

const rt_uint8_t __lowest_bit_bitmap[] =
{
	/* 位号 */
    /* 00 */ 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 10 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 20 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 30 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 40 */ 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 50 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 60 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 70 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 80 */ 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* 90 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* A0 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* B0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* C0 */ 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* D0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* E0 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
    /* F0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};




/*
	该函数用于从一个32位的数中寻找第一个被置1的位（从低位开始）
	返回该位的索引（即位号）
*/
int __rt_ffs(int value)
{
	
	if ( value == 0 )
		return 0;
	
	
	// 加1表示区别于输入为0时，返回0的情况，返回1表示优先级为0就绪
	
	// 检查bits [07:00]
	if ( value & 0xff )
		return __lowest_bit_bitmap[value & 0xff] + 1 ;
	
	// 检查bits [15:08]
	if ( value & 0xff00 )
		return __lowest_bit_bitmap[ (value & 0xff00) >> 8 ] + 9 ;
	
	// 检查bits [23:16]
	if ( value & 0xff0000 )
		return __lowest_bit_bitmap[ (value & 0xff0000) >> 16 ] + 17 ;
	
	// bits [31:24]
	return __lowest_bit_bitmap[ (value & 0xff000000) >> 24 ] + 25 ;
	
}


